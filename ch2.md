# 데이터 모델과 질의 언어
- 데이터 모델은 SW 개발에서 가장 중요한 부분
- 대부분의 어플리케이션은 여러 계층의 데이터 모델 존재
    - 어플리케이션 개발자는 현실의 데이터 구조를 다루는 API 모델링
    - 데이터 구조는 JSON과 같은 범용 데이터 모델로 표현
    - DB SW 개발자는 데이터를 메모리/디스크/네트워크 상에서 표현하는 방법 결정
    - HW 엔지니어는 전류 등의 관점에서 바이트 표현
- 계층적 구조를 통해 하위 계층의 복잡성 숨김
    - 다른 그룹의 사람들이 효율적으로 일할 수 있음
- 다양한 범용 데이터 모델
# 관계형 모델과 문서 모델
## 관계형 모델
- 데이터는 관계(테이블)로 구성되고 각 관계는 튜플(row)의 모음
- 70, 80년대 네트워크 모델과 계층 모델이 주요 대안이었지만 관계형 모델이 경쟁에서 우위 차지
## NoSQL
- 뛰어난 확장성으로 High throughput을 RDB보다 쉽게 달성
- 무료 오픈소스 소프트웨어
- 관계형 모델에서 지원하지 않은 특수 질의
- 관계형 스키마의 제한에 대한 불만
- 표현력이 풍부한 데이터 모델에 대한 바람
## 객체 관계형 불일치
- 임피던스 불일치
    - 객체지향 프로그래밍 언어로 개발할 때 코드와 모델 객체 간 전환 계층 필요
    - ActiveRecord나 Hibernate와 같은 ORM 프레임워크가 전환 계층에 도움을 줌
    - 그러나 두 모델 간 차이 완벽히 숨길 수 없음
- 링크드인 프로파일
    - user_id로 식별
    - 이름 정보는 one-to-one 이지만 학력, 직위와 같은 항목은 one-to-many
- 일대다 관계에 대한 구현 방법은 여러가지
    - 전통적인 SQL 모델은 one-to-many 항목에 대한 개별 테이블 생성 후 user 테이블을 참조하는 방식으로 구현
    - SQL에서 구조화된 데이터타입(XML, JSON 등)에 대한 지원을 통한 구현
        - 단일 row에 다중값 저장 가능
        - 문서 내 질의/색인 가능
    - 정보를 JSON이나 XML로 인코딩하여 텍스트로 저장하여 구현
        - 일반적으로 부호회된 칼럼의 값을 질의하는 DB 사용 불가
- JSON 모델
    - 이력서같은 데이터 구조는 JSON으로 표현하기 적합
        - XML보다 간단함
    - 문서 지향 데이터베이스
        - MongoDB, CouchDB, Espresso
    - JSON 모델이 임피던스 불일치를 줄일까?
        - JSON이 가진 문제 또한 존재
    - 다중 테이블 스키마보다 더 나은 지역성
        - 테이블을 따로 생성하는 방식은 프로필 하나를 가져오기 위해 여러번의 질의 필요
        - 그러나 JSON 모델에서는 관련 정보가 하나의 문서에 존재해서 하나의 질의로 충분
    - JSON 모델에서는 일대다 관계에 대한 데이터 트리 구조가 명시적으로 드러남
## 다대일과 다대다 관계
- 링크드인 프로필 예제에서 지역 정보와 기업 정보는 id로 저장
    - 해당 정보 업계 표준 목록으로 드롭다운 리스트나 자동 완성을 통해 정해진 값 입력하게 유도
    - 일관된 정보, 모호함 없음
    - 갱신의 편의성
    - 현지화 지원
    - 더 나은 검색
- id 정보는 해당 레코드에서만 유의미, 텍스트 정보는 해당 레코드 외에서도 유의미
- id 정보는 변경할 필요x
- 텍스트 정보는 DB 외에서도 해당 값이 쓰일수 있어 여러번 변경해야함
- 다대일 관계는 중복된 데이터 정규화를 위해 필요
    - ex. 특정 단일 데이터를 여러 소스에서 사용한다면 다대일 관계 필요
    - RDB에서는 조인이 쉬워 ID로 다른 테이블의 로우 참조하는 방식으로 다대일 관계 구현
    - 문서 모델에는 조인에 대한 지원이 약함
        - 문서 모델이 다대일 관계에 약한 원인
- DB에서 조인을 지원하지 않을 경우 여러 쿼리에 걸쳐 조인 구현
- 어플리케이션에 기능을 추가하면서 데이터는 상호 연결되고 조인이 필요해짐
    - 링크드인 예제
        - 조직과 학교에 추가 정보를 담기 위해 엔터티로 쓴다면?
        - 새로운 기능으로 추천서 기능을 추가하여 추천인/추천 받은 사용자 프로필을 참조해야 한다면?
## 문서 데이터베이스
- IBM의 정보 관리 시스템(IMS)
    - 계층 모델 사용, JSON 모델과 유사, 레코드 트리로 표현
    - 문서 DB처럼 일대다 관계는 잘 표현하지만 다대다 관계 표현을 힘듬
- 계층 모델 한계를 위한 해결책 제안
    - 관계형 모델
        - SQL
    - 네트워크 모델
### 네트워크 모델
- 코다실 모델
- 레코드는 다중 부모를 가질 수 있음 (트리 구조에서 벗어남)
- 레코드 간 연결이 FK보다 포인터와 유사
- 최상위 레코드에서부터 연속된 연결 경로인 접근 경로를 따름으로써 특정 레코드에 접근
- 다중 부모를 가질 경우 n차원 데이터 공간과 같아짐
- 제한된 HW 성능 하에서는 효율적이지만 코드가 복잡
- 원하는 데이터 경로가 없다면 새로운 접근 경로를 위한 재작성 필요
### 관계형 모델
- 복잡한 접근경로x
- 임의 조건과 일치하는 테이블의 일부 혹은 모든 row 읽기 가능
- 일부 칼럼을 키로 지정 가능
- 외래 키 상관 없이 임의 테이블에 새 row 삽입 가능
- 질의 최적화기(Query Optimizer)
    - 질의 순서 및 사용할 인덱스 자동 결정
    - 네트워크 모델의 접근 경로와 마찬가지
    - 그러나 개발자가 아닌 질의 최적화기가 자동으로 만들기에 접근 경로를 생각할 필요x
### 문서 데이터베이스와의 비교
- 문서 DB의 경우 일대다 관계에 대해서는 상위 레코드 내 중첩된 레코드 저장
    - JSON attribute가 JSON의 list가 될 수 있음
- 다대일/다대다 관계에서는 RDB와 근본적으로 같음
    - 관계형 모델에서는 FK, 문서 모델에서는 문서 참조 (문서의 id 사용)
## RDB와 문서 DB
- 내결함성과 동시성 처리 등에서 차이점 많음
- 데이터 모델 측면에는 다음과 같은 차이점 존재
    - 문서 DB는 높은 스키마 유연성과 지역성에 기인한 높은 성능을 가지고 어플리케이션 데이터 구조가 문서 형태에 더 가까움
    - RDB는 조인, 다대일, 다대다 관계에 대한 지원이 더 좋음
### 어떤 데이터 모델이 어플리케이션 코드를 더 간단하게 할까?
- 어플리케이션 데이터는 문서와 비슷한 구조를 가지면 문서 모델 유리
- 중첩 항목을 바로 참조 불가하기에 참조할 데이터의 위치를 명시해야함
    - ex) 사용자 251 직위 목록의 두번째 항목
    - 접근 경로와 유사
    - 중첩이 너무 깊지만 않으면 문제x
- 미흡한 조인 지원
    - 로그 DB에 대해선 다대다 관계 필요x
    - 다대다 관계를 사용하는 어플리케이션이라면 문서 모델 불리
        - 비정규화를 통해 조인을 줄일 수는 있지만 일관성 유지에 추가 비용
        - 조인을 흉내내는 다중 쿼리는 낮은 성능
### 문서 모델 스키마 유연성
- 특정 스키마 제한x
- Schemaless하지는 않음
    - MongoDB에도 ORM 존재
    - 그러나 DB에서 강요x
- RDB에서 schema-on-write 이라면 문서 DB는 schema-on-read
    - 마치 정적 타입 확인 vs 동적 타입 확인
- 데이터 타입 변경하고자 할 때 큰 차이
    - 특정 필드 추가하고 싶을 때
        - 문서 DB에서는 특정 필드 유무 확인 후 없으면 추가
        - RDB에서는 마이그레이션 수행
            - ALTER TABLE
            - 느리고 중단시간 요구
            - 대부분의 RDBMS는 빠르지만 MySQL은 전체 테이블을 복사하기에 많은 시간이 걸림
            - NULL 처리 후 읽는 시점에서 처리할 수도 있음 (문서 DB와 유사)
- 컬렉션 내 데이터들이 모두 동일한 구조가 아니면 문서 DB 유리
### 질의를 위한 데이터 지역성
- 문서 DB에서는 저장소 지역성을 활용하면 성능 이점 존재
- 일반적으로 문서 접근 시 전체 문서 적재하기 때문
- 문서가 크면 비효율, 크기 작게 유지해야 지역성 활용 가능
- 이러한 제한 때문에 지역성 활용에 대한 한계 존재
- 다른 모델에서도 지역성 사용
    - 구글 Spanner DB
        - 부모 테이블 내에 테이블의 row 교차 배치
    - Oracle DB
        - 다중 테이블 색인 클러스터 테이블
    - HBase
        - Column Family
### 문서 DB와 RDB 통합
- RDB에서는 XML과 JSON과 같은 문서 DB에서 사용하는 데이터 구조 지원
- 리싱크DB에서 조인 지원
- 몽고DB DBRef
    - 문서 id 및 db 이름을 통해 다른 DB의 문서 참조 가능
    - 네트워크 오버헤드 및 최적화 이슈 때문에 조인보다는 느림
# 질의 언어
- 선언형 질의 언어
    - SQL
    - 목표를 달성하기 위한 방법이 아님
    - 원하는 데이터를 지정하기만 함
    - 순서 보장x
    - 인터페이스와 실제 구현 간 분리
    - 병렬 실행에 적합
- 명령형 코드
    - IMS, 코다실
    - 마치 프로그래밍 언어
    - DB 입장에선 해당 코드가 순서에 의존하는지 알 수 없음
## 웹에서의 선언형 질의
- CSS나 XSL의 경우 선언형에 가까움
- 자바스크립트의 경우 명령형
    - 렌더링이 다시 되었을 때 문제 생길 수 있음
    - 새로운 API로 바꾸고자 할 때 재작성 필요
## 맵리듀스 질의
- 맵리듀스는 선언형과 명령형 중간
- map과 reduce 함수 기반
- 특정 기간 동안 기록된 데이터 개수 구하기 예시
    - postgresql에서는 date_trunc를 통해 timestamp의 월 부분만 추출하고 월 별로 group by
    - MR에서는 timestamp의 month 부분을 key, 빈도수를 value로 매핑하는 연산을 map 함수로 사용하고 빈도수를 모두 합하는 연산을 reduce 함수로 사용
- 클러스터 환경에서 MR은 저수준 프로그래밍 모델
    - MR 없이 분산 SQL 구현도 존재
- 난이도가 높다는 단점
- MongoDB에서는 aggregate 기능 추가
    - 특정 조건에 해당하는 문서 가져오는 기능
# 그래프형 데이터 모델
- 다대다 관계가 일반적인 복잡한 구조에서는 그래프로 모델링 하는 것이 자연스러움
- 그래프는 특정 데이터 유형에 국한되지 않고 표현 가능
    - 페이스북 예시
        - 사람, 장소, 이벤트, 체크인, 코멘트를 정점으로 표현
        - 친구 관계, 체크인 위치 등이 간선
- 다양한 그래프 모델
    - 속성 그래프 모델
    - 트리플 저장소 모델
## 속성 그래프
- 정점은 다음과 같은 요소로 구성
    - 식별자
    - 유출 간선(outgoing edge) 집합
    - 유입 간선(incoming edge) 집합
    - 속성 컬렉션(Key-Value)
- 간선
    - 식별자
    - 간선 시작/끝 정점
    - 레이블
    - 속성 컬렉션(Key-Value)
- 정점 간에는 간선으로 연결
    - 특정 데이터 유형을 제한하는 스키마x
- 정점이 주어지면 해당 정점과 인접한 간선을 통해 그래프 순회 가능
- 관계에 따라 간선에 다른 레이블을 사용
### 사이퍼 질의 언어
- 속성 그래프를 위한 선언형 질의 언어
- 그래프 DB로 데이터 삽입하는 질의 예시
```
CREATE
    (NAmerica:Location {name: 'North America, type: 'continent'})
    ...
    (Idaho) -[:WITHIN]-> (USA) -[:WITHIN]-> (NAmerica),
    (Lucy) -[:BORN_IN]-> (Idaho)
```
- 미국에서 유럽으로 이민 온 모든 사람들의 이름 찾는 질의 예시
    - person은 BORN_IN 유출 간선을 가지며 name 속성이 United State인 Location 유형의 정점에 도달할 때까지 WITHIN 유출 간선 따라감
    - person은 LIVES_IN 유출 간선을 가지며 name이 Europe인 Location 유형의 정점에 도달할 때까지 WITHIN 유출 간선 따라감
    - 각 person 정점마다 name 속성 반환
```
MATCH
    (person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name:'United State'}),
    (person) -[:LIVES_IN]-> () - [:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
```
- 질의 실행에는 여러 방법 존재
    - 전체 person 정점 중 조건에 맞는 사람 반환
    - Location 정점에서 시작하여 간선의 역방향으로 person 찾음
        - name 속성에 색인이 있다면 효율적으로 해당하는 정점 찾을 수 있음
### SQL 그래프 질의
- 그래프 데이터를 RDB에 넣어도 SQL로 질의 가능, 그러나 복잡
    - 질의에 필요한 조인을 미리 알고 있어야 함
    - 그러나 그래프 질의에서는 간선 순회가 몇번 일어나는지 알 수 없기 때문에 조인 수 고정 불가
    - 하지만 위의 사이퍼 질의에서는 `() -[:WITHIN*0..]-> ()`를 통해 간선 순회 간결히 표현
- SQL에서는 재귀 공통 테이블 식(WITH RECURSIVE)를 통해 가변 순회 경로 질의 구현
    - 문법이 어렵다는 단점
    - 마치 while 문과 같은 동작
    - 반복적인 연산을 통해 새로운 임시 테이블을 구성하여 최종적으로 원하는 데이터 가져옴
    - 반복적인 연산 과정에서 그래프 순회
## 트리플 저장소와 스파클
- 트리플 저장소 모델은 속성 그래프 모델과 유사
    - 용어만 다름
    - 주어(subect, =정점)
    - 서술어(predicate)
    - 목적어(object)
- 터틀 형식의 트리플 예제
    - 동일한 주어에 대한 작업을 세미 콜론으로 더 간결하게 작성 가능
```
@prefix <urn:example:>.
_: lucy a :Person.
_: lucy :name "Lucy".
...
```
### 시멘틱 웹
- 트리플 저장소 데이터 모델과 시맨틱 웹은 독립적
- 시맨틱 웹이란 기계가 판독 가능한 데이터로 정보 게시
    - 과대평가
### RDF 데이터 모델
- XML과 비슷하지만 더 간단
### 스파크 질의 언어
- RDF 데이터 모델 사용한 트리플 저장소 질의 언어
- 사이퍼보다 간결
```
SELECT ?personName WHERE {
    ?person :name ?personName.
    ?person :bornIn / :within* / :name "United State".
    ?person :livesIn / :within* / :name "Europe".
}
```
- RDF는 속성과 간선 구별x, 서술어만 사용
- 시맨틱 웹이 아니더라도 사용 가능
### 그래프 데이터베이스 vs 코다실 데이터베이스
- 코다실 데이터베이스는 그래프 데이터베이스와 달리 스키마 존재
- 코다실에서 접근 경로만을 이용해 레코드 탐색, 그래프 데이터베이스는 색인 사용
- 코다실에서는 레코드 하위 항목 정렬, 그래프에서는 정렬x
- 코다실에서는 명령형 질의, 그래프에서는 선언형/명령형 둘 다 가능하지만 주로 선언형 질의 제공
## 데이터로그
- 오래된 언어 (80년대 연구)
- 질의 언어의 초석
- 트리플 저장소 모델과 유사하지만 조금 더 일반화
    - (주어, 서술어, 목적어)가 아닌 서술어(주어, 목적어)
```
name(namerica, "North America")
type(namerica, continent)
```
- 질의
    - 함수 형태
    - 재귀 호출 될 때 마다 해당하는 row가 테이블에 쌓임
```
within_recursive(Location, Name) :- name(Location, Name).

within_recursive(Location, Name) :- within(Location, Via),
                                within_recursive(Via, Name).

migrated(Name, BornIn, LivingIn) :- name(Person, Name),
                                born_in(Person, BornLoc),
...

?- migrated(Who, 'United States', 'Europe')
```
# 정리
- RDB가 적합하지 않은 경우 - NoSQL
    - 문서 DB
    - 그래프 DB
- 어떤 DB를 사용할지는 목적에 따라 다름
    - 다양한 시스템을 보유해야함
- 문서/DB의 공통점은 스키마 유연성
    - 스키마가 Write에 필요한지 Read에 필요한지에 따라 유연성 달라짐
- 각 데이터 모델마다 고유의 질의 언어 혹은 프레임워크 제공
- 다양한 데이터 모델
    - genome 데이터
    - 입자 물리학
    - full-text 검색